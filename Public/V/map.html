<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=0.5, maximum-scale=0.5, minimum-scale=1.0">
    <meta name="description" content="废土战记">
    <meta name="author" content="路漫漫">
    <title>Title</title>
    <script src="http://cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
</head>
<style>
    @keyframes aniMove{
        100%{background-position-x:72px;}
    }

    @keyframes aniFrame{
        100%{background-position-x:72px;}
    }

    #sprite {
        width: 24px;
        height: 24px;
        background-image: url("http://game.duanxq.cn/images/charasets/NPC (6).png");
        animation: aniMove steps(3,end) 0.3s infinite;
        animation-play-state:paused;
    }

</style>
<body>
<!--<div id="sprite"></div>-->
<!--<button id="restart" onclick="reset();">退出游戏</button>-->
</body>
<script src="./Static/js/resources.js"></script>
<script src="./Static/js/sprite.js"></script>
<script src="./Static/js/input.js"></script>
<script src="./Static/js/gameLib.js"></script>
<script src="./Static/js/mapTest.js"></script>
<script>
    var mapWidth,
        mapHeight,
        tileSet,
        imgObj,
        map,
        player,
        mapPass=[[]],
        canvas,
        canvas2,
        ctx,
        ctx2,
        terrainPattern,
        terrainPattern1,
        tileSize=24,
        eventObj,
        eventArr={},
        moving = false,
        btnState = false,
        eventKey=0,
        eventState = false;

    function getMapData () {
        $.post('http://e.cn/Public/getMapTest', {uid:userInfo.id}, function (result) {
            mapDataProcess(result);
            delete result;
        });
    }
    getMapData();


    //地图
    var urlArr = ['/V/Static/assets/home2_0.png','/V/Static/assets/home2_1.png',"/V/Static/img/movePic/NPC_1.png"];

    function init() {
        imgObj = resources.get();
        mapHeight = imgObj[urlArr[0]].height;
        mapWidth = imgObj[urlArr[0]].width;
        lastTime = Date.now();
        player = {
            pos: [4, 8],
            p: {x:4*tileSize,y:8*tileSize},
            sprite: new Sprite(urlArr[2], [0, 0], [tileSet.tilewidth,tileSet.tileheight], 10, [0, 1, 2, 3])
        };
        createCanavs();
        main();
    }

    // 页面重绘前，通知浏览器调用一个指定的函数
    // 具体看https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame
    var requestAnimFrame = (function(){
        return window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function(callback){
                window.setTimeout(callback, 1000 / 60);//一秒60帧
            };
    })();
    function createCanavs() {
        canvas = document.createElement("canvas");
        canvas2 = document.createElement("canvas");
        ctx = canvas.getContext("2d");
        ctx2 = canvas2.getContext("2d");
        canvas2.width = canvas.width = mapWidth;
        canvas2.height = canvas.height = mapHeight;
        document.body.appendChild(canvas);
        document.body.appendChild(canvas2);
        $(canvas).css({
            "position": "absolute",
            "z-index": 1
        });
        $(canvas2).css({
            "position": "absolute",
            "z-index": 1
        });

        terrainPattern  = ctx.createPattern(imgObj[urlArr[0]],'no-repeat');
        terrainPattern1  = ctx.createPattern(imgObj[urlArr[1]],'no-repeat');

        ctx2.fillStyle = terrainPattern1;
        ctx2.fillRect(0, 0, mapWidth, mapHeight);
        getMousePos(canvas2,getCanavsClickPoint);
    }

    // The main game loop
    var lastTime;
    function main() {
        var now = Date.now();
        var dt = (now - lastTime) / 1000.0;

        update(dt);
        render();

        lastTime = now;
        requestAnimFrame(main);
    }

    // Game state
    var gameTime = 0;
    var playerSpeed = 2,dir=-1;

    function update(dt) {
        gameTime += dt;
        handleInput(dt);
        movingAnim();
        player.sprite.update(dt);
    }

    //0:down 1:left 2:right 3:up
    function movingAnim() {
        if (!moving) return;
        player.sprite.running = true;
        switch (dir){
            case 0:
                var p = (player.pos[1]+1)*tileSize;
                player.p.y += playerSpeed;
                if(player.p.y >= p){
                    player.sprite.running = moving = false;
                    player.pos[1] += 1;
                }
                break;
            case 1:
                var p = (player.pos[0]-1)*tileSize;
                player.p.x -= playerSpeed;
                if(player.p.x <= p){
                    player.sprite.running = moving = false;
                    player.pos[0] -= 1;
                }
                break;
            case 2:
                var p = (player.pos[0]+1)*tileSize;
                player.p.x += playerSpeed;
                if(player.p.x >= p){
                    player.sprite.running = moving = false;
                    player.pos[0] += 1;
                }
                break;
            case 3:
                var p = (player.pos[1]-1)*tileSize;
                player.p.y -= playerSpeed;
                if(player.p.y <= p){
                    player.sprite.running = moving = false;
                    player.pos[1] -= 1;
                }
                break;
        }

    }

    function handleInput() {
        if(moving) return;
        if (input.isDown('DOWN') || input.isDown('s')) {
            console.log('s');
            player.sprite.pos = [0, 0 * tileSize];
            dir = 0;
            if (checkCollisions(player.pos[0], player.pos[1]+1)){
                moving = true;
            }
        }

        if (input.isDown('UP') || input.isDown('w')) {
            console.log('w');
            player.sprite.pos = [0, 3 * tileSize];
            dir = 3;

            if (checkCollisions(player.pos[0], player.pos[1]-1)){
                moving = true;
            }

        }

        if (input.isDown('LEFT') || input.isDown('a')) {
            console.log('a');
            player.sprite.pos = [0, 1 * tileSize];
            dir = 1;

            if (checkCollisions(player.pos[0]-1, player.pos[1])){
                moving = true;
            }
        }

        if (input.isDown('RIGHT') || input.isDown('d')) {
            console.log('d');
            player.sprite.pos = [0, 2 * tileSize];
            dir = 2;

            if (checkCollisions(player.pos[0] + 1, player.pos[1])){
                moving = true;
            }
        }
        if (input.isDown('space') || input.isDown('enter')) {
            if(btnState) return;
            btnState = true;
            mapEventTirgger();
//            console.log();

        }

    }

    // Draw everything
    function render() {
        ctx.fillStyle = terrainPattern;
        ctx.fillRect(0, 0, mapWidth, mapHeight);
        renderEntity(player);
        renderEntities(eventArr);

    }

    function renderEntities(list) {
        for (var k in list) {
            renderEntity(list[k]);
        }
    }

    function renderEntity(entity) {
        ctx.save();
        ctx.translate(entity.p.x, entity.p.y);
        entity.sprite.render(ctx);
        ctx.restore();
    }

    /**
     * Tile map data process
     */
    function mapDataProcess(data) {

        //get tile set data
        tileSet = data.tilesets[0];
        delete data.tilesets;

        //get tile map data
        map = data;
        delete data;

        //get tile map pass array
        mapPassProcess();
        mapEventProcess();

        //load resources
        urlArr.push('/V/Static/assets/'+tileSet.image);
        resources.load(urlArr);
        resources.onReady(init);
    }

    /**
     * tile map pass array
     */
    function mapPassProcess() {
        eventObj = map.layers.pop().objects;
        var layer = map.layers.pop().data,layerLen;
        layerLen = layer.length;
        var j=0,x=0,width=map.width;
        for (var i = 0; i < layerLen; i++,x++) {
            var y = Math.floor(i/width);
            if (j !== y){x=0;j=y;mapPass.push([]);}
            mapPass[j].push(layer[i]);
        }
    }

    /**
     * tile map event data process
     */
    function mapEventProcess() {
        var len = eventObj.length;
        for (var i = 0; i < len; i++) {
            addEvent(eventObj[i]);
        }
        delete eventObj;
    }

    /**
     * map event tirgger
     */
    function mapEventTirgger() {
        var eventData={},name;
        switch (dir){
            case 0:
                name = player.pos[0]+'_'+(player.pos[1]+1);
                break;
            case 1:
                name = (player.pos[0]-1)+'_'+player.pos[1];
                break;
            case 2:
                name = (player.pos[0]+1)+'_'+player.pos[1];
                break;
            case 3:
                name = player.pos[0]+'_'+(player.pos[1]-1);
                break;
        }

        $.post('http://e.cn/Public/getEventTest', {uid:userInfo.id}, eventShow);

//        return ;
    }

    function eventShow(result){
        var id,content;
        id = result[eventKey][0];
        content = result[eventKey][1];
        switch (id){
            case -1:
                return;
                break;
            case 1:
                showMessage(content[0]);
                break;
        }
        eventKey++;
    }



</script>
<script src="./Static/js/collision.js"></script>
</html>
