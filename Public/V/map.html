<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=0.5, maximum-scale=0.5, minimum-scale=1.0">
    <meta name="description" content="废土战记">
    <meta name="author" content="路漫漫">
    <title>Title</title>
    <script src="http://cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
</head>
<style>
    @keyframes aniMove{
        100%{background-position-x:72px;}
    }

    @keyframes aniFrame{
        100%{background-position-x:72px;}
    }

    #sprite {
        width: 24px;
        height: 24px;
        background-image: url("http://game.duanxq.cn/images/charasets/NPC (6).png");
        animation: aniMove steps(3,end) 0.3s infinite;
        animation-play-state:paused;
    }

</style>
<body>
<!--<div id="sprite"></div>-->
<!--<button id="restart" onclick="reset();">重新开始</button>-->
</body>
<script src="./Static/js/resources.js"></script>
<script src="./Static/js/sprite.js"></script>
<script src="./Static/js/input.js"></script>
<script src="./Static/js/gameLib.js"></script>
<script src="./Static/js//mapTest.js"></script>
<script>
    var mapWidth,mapHeight,tileSet,imgObj,map,player,mapPass=[[]],canvas,canvas2,ctx,ctx2,terrainPattern,terrainPattern1,tileSize=24,eventObj,eventArr={},moving = false;
//    var id = userInfo.id;

    $.post('http://e.cn/Public/index', {}, function (result) {
        mapDataProcess(result);
        delete result;
    });

    //地图
    var urlArr = ['/V/Static/assets/home_0.png','/V/Static/assets/home_1.png',"/V/Static/img/movePic/NPC_1.png"];

    function init() {
        imgObj = resources.get();
        mapHeight = imgObj[urlArr[0]].height;
        mapWidth = imgObj[urlArr[0]].width;
        lastTime = Date.now();
        player = {
            pos: [4, 8],
            p: {x:4*tileSize,y:8*tileSize},
            sprite: new Sprite(urlArr[2], [0, 0], [tileSet.tilewidth,tileSet.tileheight], 10, [0, 1, 2, 3])
        };
//        mapEventProcess();

        createCanavs();
        main();
    }

    // 页面重绘前，通知浏览器调用一个指定的函数
    // 具体看https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame
    var requestAnimFrame = (function(){
        return window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function(callback){
                window.setTimeout(callback, 1000 / 60);//一秒60帧
            };
    })();
    function createCanavs() {
        canvas = document.createElement("canvas");
        canvas2 = document.createElement("canvas");
        ctx = canvas.getContext("2d");
        ctx2 = canvas2.getContext("2d");
        canvas2.width = canvas.width = mapWidth;
        canvas2.height = canvas.height = mapHeight;
        document.body.appendChild(canvas);
        document.body.appendChild(canvas2);
        $(canvas).css({
            "position": "absolute",
            "z-index": 1
        });
        $(canvas2).css({
            "position": "absolute",
            "z-index": 1
        });

        terrainPattern  = ctx.createPattern(imgObj[urlArr[0]],'no-repeat');
        terrainPattern1  = ctx.createPattern(imgObj[urlArr[1]],'no-repeat');

        ctx2.fillStyle = terrainPattern1;
        ctx2.fillRect(0, 0, mapWidth, mapHeight);
        getMousePos(canvas2,getCanavsClickPoint);


    }

    // The main game loop
    var lastTime;
    function main() {
        var now = Date.now();
        var dt = (now - lastTime) / 1000.0;

        update(dt);
        render();

        lastTime = now;
        requestAnimFrame(main);
    }

    // Game state
    var gameTime = 0;
    var playerSpeed = 2,dir=-1;

    function update(dt) {
        gameTime += dt;
        handleInput(dt);
        movingAnim();
        player.sprite.update(dt);
    }

    //0:down 1:left 2:right 3:up
    function movingAnim() {
        if (dir===-1) return;
        player.sprite.running = moving = true;
        switch (dir){
            case 0:
                player.sprite.pos = [0, dir * tileSize];
                var p = (player.pos[1]+1)*tileSize;
                player.p.y += playerSpeed;
                if(player.p.y >= p){
                    player.sprite.running = moving = false;
                    dir=-1;
                    player.pos[1] += 1;
                }
                break;
            case 1:
                player.sprite.pos = [0, dir * tileSize];
                var p = (player.pos[0]-1)*tileSize;
                player.p.x -= playerSpeed;
                if(player.p.x <= p){
                    dir=-1;
                    player.sprite.running = moving = false;
                    player.pos[0] -= 1;
                }
                break;
            case 2:
                player.sprite.pos = [0, dir * tileSize];
                var p = (player.pos[0]+1)*tileSize;
                player.p.x += playerSpeed;
                if(player.p.x >= p){
                    dir=-1;
                    player.sprite.running = moving = false;
                    player.pos[0] += 1;
                }
                break;
            case 3:
                player.sprite.pos = [0, dir * tileSize];
                var p = (player.pos[1]-1)*tileSize;
                player.p.y -= playerSpeed;
                if(player.p.y <= p){
                    dir=-1;
                    player.sprite.running = moving = false;
                    player.pos[1] -= 1;
                }
                break;
        }

    }

    function handleInput() {
        if(moving) return;
        if (input.isDown('DOWN') || input.isDown('s')) {
            console.log('s');
            if (checkCollisions(player.pos[0], player.pos[1]+1)) dir = 0;
        }

        if (input.isDown('UP') || input.isDown('w')) {
            console.log('w');
            if (checkCollisions(player.pos[0], player.pos[1]-1)) dir = 3;
        }

        if (input.isDown('LEFT') || input.isDown('a')) {
            console.log('a');
            if (checkCollisions(player.pos[0]-1, player.pos[1])) dir = 1;
        }

        if (input.isDown('RIGHT') || input.isDown('d')) {
            console.log('d');
            if (checkCollisions(player.pos[0] + 1, player.pos[1])) dir = 2;
        }
    }

    // Draw everything
    function render() {
        ctx.fillStyle = terrainPattern;
        ctx.fillRect(0, 0, mapWidth, mapHeight);
        renderEntity(player);
        renderEntities(eventArr);

    }

    function renderEntities(list) {
        for (var k in list) {
            renderEntity(list[k]);
        }
    }

    function renderEntity(entity) {
        ctx.save();
        ctx.translate(entity.p.x, entity.p.y);
        entity.sprite.render(ctx);
        ctx.restore();
    }

    /**
     * Tile map data process
     */
    function mapDataProcess(data) {

        //get tile set data
        tileSet = data.tilesets[0];
        delete data.tilesets;

        //get tile map data
        map = data;
        delete data;

        //get tile map pass array
        mapPassProcess();
        mapEventProcess();

        //load resources
        urlArr.push('/V/Static/assets/'+tileSet.image);
        resources.load(urlArr);
        resources.onReady(init);
    }

    /**
     * Render tile map
     */
    function mapPassProcess() {
        eventObj = map.layers.pop().objects;
        var layer = map.layers.pop().data,layerLen;
        layerLen = layer.length;
        var j=0,x=0,width=map.width;
        for (var i = 0; i < layerLen; i++,x++) {
            var y = Math.floor(i/width);
            if (j !== y){x=0;j=y;mapPass.push([]);}
            mapPass[j].push(layer[i]);
        }
    }

    /**
     * Render tile map
     */
    function mapEventProcess() {
        var len = eventObj.length;
        for (var i = 0; i < len; i++) {
            addEvent(eventObj[i]);
        }
        delete eventObj;
    }

</script>
<script src="./Static/js/collision.js"></script>
</html>
